# -*- coding: utf-8 -*-
"""Assignment2(NikhilKumar).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cQvgnCM3C_9f9QPoLpXsB_xOJwyiJI5D
"""

class Node:
    """
    Represents a single node in a singly linked list.
    Each node contains data and a reference to the next node.
    """
    def __init__(self, data):
        self.data = data  # Store the data value of the node
        self.next = None  # Reference to the next node (initialized as None)

class LinkedList:
    """
    Manages a singly linked list composed of Node objects.
    Provides methods to add nodes, print the list, and delete nodes by position.
    """
    def __init__(self):
        self.head = None  # Initially, the linked list is empty (head is None)

    def add_node(self, data):
        """
        Add a new node with the given data to the end of the linked list.
        :param data: Data value to be stored in the new node.
        """
        new_node = Node(data)  # Create a new node instance
        if not self.head:
            # If list is empty, make new node the head
            self.head = new_node
            return
        # Otherwise, traverse to the last node and append the new node
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node

    def print_list(self):
        """
        Print all values in the linked list in order.
        If the list is empty, informs the user accordingly.
        """
        current_node = self.head
        if not current_node:
            print("The list is empty.")
            return

        while current_node:
            print(current_node.data, end=" -> ")
            current_node = current_node.next
        print("None")  # Indicate the end of the list

    def delete_nth_node(self, n):
        """
        Delete the node at the nth position in the list (1-based index).
        Raises exceptions for empty list, invalid index, or out-of-range index.
        :param n: 1-based index of the node to delete.
        """
        if not self.head:
            raise Exception("Cannot delete from an empty list.")

        if n < 1:
            raise Exception("Index must be a positive integer.")

        current_node = self.head

        # Special case: if deleting the head node (1st node)
        if n == 1:
            self.head = current_node.next
            return

        # Traverse to the node immediately before the one to delete
        for _ in range(n - 2):
            current_node = current_node.next
            if current_node is None:
                raise Exception("Index out of range.")

        # If the next node is None, index is out of range
        if current_node.next is None:
            raise Exception("Index out of range.")

        # Bypass the nth node, effectively deleting it
        current_node.next = current_node.next.next

def add_node(self, data):
        """
        Add a new node with the given data to the end of the linked list.
        :param data: Data value to be stored in the new node.
        """
        new_node = Node(data)  # Create a new node instance
        if not self.head:
            # If list is empty, make new node the head
            self.head = new_node
            return
        # Otherwise, traverse to the last node and append the new node
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node

def print_list(self):
        """
        Print all values in the linked list in order.
        If the list is empty, informs the user accordingly.
        """
        current_node = self.head
        if not current_node:
            print("The list is empty.")
            return

        while current_node:
            print(current_node.data, end=" -> ")
            current_node = current_node.next
        print("None")  # Indicate the end of the list

def delete_nth_node(self, n):
        """
        Delete the node at the nth position in the list (1-based index).
        Raises exceptions for empty list, invalid index, or out-of-range index.
        :param n: 1-based index of the node to delete.
        """
        if not self.head:
            raise Exception("Cannot delete from an empty list.")

        if n < 1:
            raise Exception("Index must be a positive integer.")

        current_node = self.head

        # Special case: if deleting the head node (1st node)
        if n == 1:
            self.head = current_node.next
            return

        # Traverse to the node immediately before the one to delete
        for _ in range(n - 2):
            current_node = current_node.next
            if current_node is None:
                raise Exception("Index out of range.")

        # If the next node is None, index is out of range
        if current_node.next is None:
            raise Exception("Index out of range.")

        # Bypass the nth node, effectively deleting it
        current_node.next = current_node.next.next

# Demonstration and testing of the LinkedList class
if __name__ == "__main__":
    linked_list = LinkedList()

    print("Adding nodes to the linked list:")
    linked_list.add_node(1)
    linked_list.add_node(2)
    linked_list.add_node(3)
    linked_list.add_node(4)
    linked_list.print_list()  # Expected: 1 -> 2 -> 3 -> 4 -> None

    print("\nDeleting the 2nd node (which has value 2):")
    linked_list.delete_nth_node(2)
    linked_list.print_list()  # Expected: 1 -> 3 -> 4 -> None

    print("\nAttempting to delete from an empty list:")
    empty_list = LinkedList()
    try:
        empty_list.delete_nth_node(1)
    except Exception as e:
        print(f"Caught an error: {e}")

    print("\nAttempting to delete a node with index out of range:")
    try:
        linked_list.delete_nth_node(5)
    except Exception as e:
        print(f"Caught an error: {e}")